From 6c36a678fcf9488d85c3a0e4b4358222f5bbfa2f Mon Sep 17 00:00:00 2001
From: bkardosa <bkardos70@gmail.com>
Date: Wed, 9 Mar 2022 15:34:34 +0100
Subject: [PATCH] add new flash w25q01jv, FTGMAC debug messages

---
 arch/arm/boot/dts/aspeed-ast2500-pcb486.dts |  3 +-
 drivers/mtd/spi-nor/winbond.c                |  2 +
 drivers/net/ethernet/faraday/ftgmac100.c     | 97 ++++++++++++++++++++
 drivers/net/phy/marvell.c                    | 15 +++
 4 files changed, 116 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/aspeed-ast2500-pcb486.dts b/arch/arm/boot/dts/aspeed-ast2500-pcb486.dts
index 78c3bcfe7075..57330ab74195 100644
--- a/arch/arm/boot/dts/aspeed-ast2500-pcb486.dts
+++ b/arch/arm/boot/dts/aspeed-ast2500-pcb486.dts
@@ -64,7 +64,7 @@ flash@0 {
 		m25p,fast-read;
 		label = "bmc";
 		spi-max-frequency = <50000000>;
-#include "openbmc-flash-layout.dtsi"
+#include "openbmc-flash-layout-128.dtsi"
 	};
 };
 
@@ -100,6 +100,7 @@ &mac0 {
 
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_rgmii1_default &pinctrl_mdio1_default>;
+	/* phy-mode = "rgmii-txid"; */
 };
 
 &mac1 {
diff --git a/drivers/mtd/spi-nor/winbond.c b/drivers/mtd/spi-nor/winbond.c
index c783ab4ba1e4..0706f299ad0d 100644
--- a/drivers/mtd/spi-nor/winbond.c
+++ b/drivers/mtd/spi-nor/winbond.c
@@ -104,6 +104,8 @@ static const struct flash_info winbond_parts[] = {
 			    SECT_4K | SPI_NOR_QUAD_READ | SPI_NOR_DUAL_READ) },
 	{ "w25q512jvq", INFO(0xef4020, 0, 64 * 1024, 1024,
 			     SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+	{ "w25q01jv", INFO(0xef4021, 0, 128 * 1024, 2048, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
+			SPI_NOR_HAS_LOCK | SPI_NOR_HAS_TB) },
 };
 
 /**
diff --git a/drivers/net/ethernet/faraday/ftgmac100.c b/drivers/net/ethernet/faraday/ftgmac100.c
index 239eb4e2e501..e01aea431921 100644
--- a/drivers/net/ethernet/faraday/ftgmac100.c
+++ b/drivers/net/ethernet/faraday/ftgmac100.c
@@ -26,9 +26,13 @@
 #include <linux/of_net.h>
 #include <net/ip.h>
 #include <net/ncsi.h>
+#include <linux/regmap.h>
+#include <linux/mfd/syscon.h>
 
 #include "ftgmac100.h"
 
+#include "../drivers/base/regmap/internal.h"
+
 #define DRV_NAME	"ftgmac100"
 
 /* Arbitrary values, I am not sure the HW has limits */
@@ -109,8 +113,36 @@ struct ftgmac100 {
 	/* Misc */
 	bool need_mac_restart;
 	bool is_aspeed;
+
+	struct regmap *scu;
 };
 
+static void scu_dump_reg( struct regmap *scu, u32 addr, int cnt )
+{
+  int ret;
+  char buf[256];
+  u32 val;
+
+  sprintf( buf, KERN_ALERT "**** SCU 0x%03x: ", addr );
+  while( cnt > 0 ) {
+	ret = regmap_read( scu, addr, &val );
+	if( ret ) {
+	  printk( KERN_ALERT "**** %s %i   ret: %i\n", __func__, (int )__LINE__, ret );
+	  break;
+	}
+	else
+	  sprintf( buf + strlen(buf), " 0x%08x", val );
+	addr += 4;
+	cnt--;
+  }
+
+  if( !ret ) {
+	strcat( buf, "\n" );
+	printk( buf );
+  }
+
+}
+
 static int ftgmac100_reset_mac(struct ftgmac100 *priv, u32 maccr)
 {
 	struct net_device *netdev = priv->netdev;
@@ -215,6 +247,11 @@ static void ftgmac100_initial_mac(struct ftgmac100 *priv)
 static int ftgmac100_set_mac_addr(struct net_device *dev, void *p)
 {
 	int ret;
+	struct ftgmac100 *priv = netdev_priv(dev);
+
+	printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__);
+	if (!!priv->scu)
+		scu_dump_reg(priv->scu, 0x48, 1);
 
 	ret = eth_prepare_mac_addr_change(dev, p);
 	if (ret < 0)
@@ -1015,6 +1052,10 @@ static void ftgmac100_adjust_link(struct net_device *netdev)
 	else
 		new_speed = phydev->speed;
 
+	printk( KERN_ALERT "**** %s %i   speed: %i\n", __func__, __LINE__, new_speed );
+	if (!!priv->scu)
+		scu_dump_reg(priv->scu, 0x48, 1);
+
 	/* Grab pause settings from PHY if configured to do so */
 	if (priv->aneg_pause) {
 		rx_pause = tx_pause = phydev->pause;
@@ -1062,12 +1103,60 @@ static int ftgmac100_mii_probe(struct net_device *netdev)
 	struct phy_device *phydev;
 	phy_interface_t phy_intf;
 	int err;
+	u32 scu48;
+
+	priv->scu = syscon_regmap_lookup_by_compatible("aspeed,ast2500-scu");
+	if (IS_ERR(priv->scu))
+		printk( KERN_ALERT "**** %s %i\n", __func__, (int )__LINE__ );
+	else {
+		printk( KERN_ALERT "**** %s %i   regmap: %s\n", __func__, (int )__LINE__, priv->scu->name );
+		scu_dump_reg( priv->scu, 0x48, 1 );
+		err = regmap_read( priv->scu, 0x48, &scu48 );
+		if ( err )
+			printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+
+		if ( !err ) {
+		  /* err = regmap_update_bits(priv->scu, 0x48, ( 0x3f << 18 ) | ( 0x3f << 12 ), ( 2 << 18 ) | ( 2 << 12 )); */
+			if ( err )
+				printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+		}
+
+		if ( !err ) {
+			err = regmap_read( priv->scu, 0x48, &scu48 );
+			if ( err )
+				printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+		}
+
+		if ( !err ) {
+		  /* err = regmap_update_bits(priv->scu, 0x48, ( 0x3f << 6 ) | ( 0x3f << 0 ), ( 8 << 6 ) | ( 0 << 0 )); */
+			if ( err )
+				printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+		}
+
+		if ( !err ) {
+			err = regmap_read( priv->scu, 0x48, &scu48 );
+			if ( err )
+				printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+		}
+
+		if ( !err ) {
+		  /* err = regmap_update_bits(priv->scu, 0x48, ( 1 << 31 ), ( 0 << 31 ) ); */
+			if ( err )
+				printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, (int )__LINE__, err );
+		}
+
+		if ( !err )
+			scu_dump_reg( priv->scu, 0x48, 1 );
+	}
 
 	/* Default to RGMII. It's a gigabit part after all */
 	err = of_get_phy_mode(np, &phy_intf);
 	if (err)
 		phy_intf = PHY_INTERFACE_MODE_RGMII;
 
+	printk( KERN_ALERT "**** %s %i   err: %i   phy_intf: 0x%08x\n",
+			__func__, __LINE__, err, phy_intf );
+
 	/* Aspeed only supports these. I don't know about other IP
 	 * block vendors so I'm going to just let them through for
 	 * now. Note that this is only a warning if for some obscure
@@ -1471,6 +1560,10 @@ static int ftgmac100_open(struct net_device *netdev)
 	struct ftgmac100 *priv = netdev_priv(netdev);
 	int err;
 
+	printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__);
+	if (!!priv->scu)
+		scu_dump_reg(priv->scu, 0x48, 1);
+
 	/* Allocate ring buffers  */
 	err = ftgmac100_alloc_rings(priv);
 	if (err) {
@@ -1547,6 +1640,10 @@ static int ftgmac100_stop(struct net_device *netdev)
 {
 	struct ftgmac100 *priv = netdev_priv(netdev);
 
+	printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__);
+	if (!!priv->scu)
+		scu_dump_reg(priv->scu, 0x48, 1);
+
 	/* Note about the reset task: We are called with the rtnl lock
 	 * held, so we are synchronized against the core of the reset
 	 * task. We must not try to synchronously cancel it otherwise
diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c
index 4fcfca4e1702..49fd1026d61c 100644
--- a/drivers/net/phy/marvell.c
+++ b/drivers/net/phy/marvell.c
@@ -541,6 +541,9 @@ static int m88e1121_config_aneg_rgmii_delays(struct phy_device *phydev)
 {
 	int mscr;
 
+	printk( KERN_ALERT "**** %s %i   interface: 0x%08x\n",
+			__func__, __LINE__, phydev->interface );
+
 	if (phydev->interface == PHY_INTERFACE_MODE_RGMII_ID)
 		mscr = MII_88E1121_PHY_MSCR_RX_DELAY |
 		       MII_88E1121_PHY_MSCR_TX_DELAY;
@@ -717,6 +720,10 @@ static int m88e1510_config_aneg(struct phy_device *phydev)
 {
 	int err;
 
+	err = phy_modify_paged(phydev, MII_MARVELL_COPPER_PAGE,
+						   0, 1 << 14, 0 << 14);
+	printk( KERN_ALERT "**** %s %i   err: %i\n", __func__, __LINE__, err );
+
 	err = marvell_set_page(phydev, MII_MARVELL_COPPER_PAGE);
 	if (err < 0)
 		goto error;
@@ -819,6 +826,9 @@ static int m88e1111_config_init_rgmii_delays(struct phy_device *phydev)
 {
 	int delay;
 
+	printk( KERN_ALERT "**** %s %i   interface: 0x%08x\n",
+			__func__, __LINE__, phydev->interface );
+
 	switch (phydev->interface) {
 	case PHY_INTERFACE_MODE_RGMII_ID:
 		delay = MII_M1111_RGMII_RX_DELAY | MII_M1111_RGMII_TX_DELAY;
@@ -2734,6 +2744,7 @@ static int marvell_probe(struct phy_device *phydev)
 {
 	struct marvell_priv *priv;
 
+	printk( KERN_ALERT "**** %s %i\n", __func__, __LINE__ );
 	priv = devm_kzalloc(&phydev->mdio.dev, sizeof(*priv), GFP_KERNEL);
 	if (!priv)
 		return -ENOMEM;
@@ -3283,6 +3294,7 @@ static struct phy_driver marvell_drivers[] = {
 module_phy_driver(marvell_drivers);
 
 static struct mdio_device_id __maybe_unused marvell_tbl[] = {
+#if 0
 	{ MARVELL_PHY_ID_88E1101, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1112, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1111, MARVELL_PHY_ID_MASK },
@@ -3303,6 +3315,9 @@ static struct mdio_device_id __maybe_unused marvell_tbl[] = {
 	{ MARVELL_PHY_ID_88E6393_FAMILY, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1340S, MARVELL_PHY_ID_MASK },
 	{ MARVELL_PHY_ID_88E1548P, MARVELL_PHY_ID_MASK },
+#else
+	{ MARVELL_PHY_ID_88E1510, MARVELL_PHY_ID_MASK },
+#endif
 	{ }
 };
 
-- 
2.25.1

